# P1.2 — Implement One Euro Filter

**Version:** 1.0.0
**Phase:** P1 (FilterCore)
**Track:** macOS
**Priority:** High
**Effort:** High
**Dependencies:** P1.1 (FilterCore API defined)
**Parallelizable:** No (Blocking for P1.3, P1.5, P1.6)
**Status:** In Progress

---

## Overview

Implement the One Euro filter algorithm in Swift to provide deterministic filtering for mouse tremor stabilization. This is the core filtering logic that will be used across the application.

---

## Context

- Part of the critical path (P1) for macOS implementation
- Required for W0.2 (Pointer Stabilization Playground) via TypeScript port
- Must handle variable delta-time and ensure no NaN/Inf output
- Performance must support 60Hz+ input rates

---

## Task Breakdown

### 1. Algorithm Implementation
- Implement the One Euro filter algorithm in Swift
- Ensure mathematical correctness and numerical stability
- Handle variable delta-time (dt) and clamping

### 2. Testing
- Unit tests for filter invariants (no NaN/Inf output, bounded output, smooth transitions)
- Edge case testing (zero input, large jumps, rapid oscillation, long pauses)
- Delta-time handling tests (dt=0, large dt, variable Hz)

### 3. Performance
- Ensure filter latency <1ms per sample
- Optimize for 60Hz+ input rates
- Memory footprint <100MB sustained

### 4. Integration
- Integrate with FilterCore API (P1.1)
- Ensure compatibility with preset mapping (P1.3)
- Prepare for TypeScript port (W0.2)

---

## Test Cases

### Unit Tests
- **No NaN/Inf Output**
  - Test with zero input, large jumps, rapid oscillation, long pauses (variable dt)
  - Verify output is always finite and bounded

- **Filter Invariants**
  - Output magnitude ≤ input magnitude
  - Smooth transition (no sudden jumps in output)
  - Monotonic response to step input

- **Delta-time Handling**
  - dt=0 doesn't cause division by zero
  - Very large dt (>1s) doesn't destabilize filter
  - Clamped dt range maintains stability
  - Consistent output regardless of frame rate (60Hz vs. 120Hz)

- **Edge Cases**
  - First input (initialization)
  - Repeated identical inputs (convergence)
  - Sign changes (tremor in opposite directions)
  - Mixed input rates (variable Hz)

---

## Acceptance Criteria

- ✓ Filter algorithm implemented in Swift
- ✓ All unit tests pass (100% pass rate)
- ✓ No NaN/Inf output under any input
- ✓ Stable filtering under variable delta-time
- ✓ Performance meets benchmarks (<1ms latency, <100MB memory)
- ✓ Compatible with FilterCore API (P1.1)
- ✓ Ready for TypeScript port (W0.2)

---

## Quality Checklist

- [ ] Algorithm matches One Euro filter specification
- [ ] All unit tests implemented and passing
- [ ] Edge cases handled (dt=0, large dt, variable Hz)
- [ ] Performance benchmarks met
- [ ] Integration with FilterCore API verified
- [ ] Documentation updated (code comments, README)

---

## Implementation Templates

### Swift Implementation Stub
```swift
class OneEuroFilter {
    private var x: Double = 0.0
    private var y: Double = 0.0
    private var dx: Double = 0.0
    private var dy: Double = 0.0
    private var lastTime: Double = 0.0

    func filter(x: Double, y: Double, timestamp: Double) -> (x: Double, y: Double) {
        // Implement One Euro filter algorithm
        return (x, y)
    }
}
```

### Test Stub
```swift
func testNoNaNOutput() {
    let filter = OneEuroFilter()
    let (x, y) = filter.filter(x: 0.0, y: 0.0, timestamp: 0.0)
    XCTAssertFalse(x.isNaN)
    XCTAssertFalse(y.isNaN)
}
```

---

## Next Steps

1. Implement the One Euro filter algorithm in Swift
2. Write unit tests for filter invariants and edge cases
3. Optimize for performance (latency, memory)
4. Integrate with FilterCore API (P1.1)
5. Prepare for TypeScript port (W0.2)

---

**End of PRD**
```

Now I will commit the PRD file.