# PRD: P1.3 — Implement Preset Mapping

**Version:** 1.0.0
**Phase:** P1 (FilterCore)
**Task:** Implement preset mapping
**Track:** macOS
**Priority:** High
**Effort:** Medium
**Dependencies:** P1.2 (One Euro filter implementation)
**Parallelizable:** Yes (Can run parallel to P1.5, P1.6)
**Status:** In Progress

## Overview

Implement preset mapping for the One Euro filter to provide predefined configurations for different use cases (e.g., fine control, general use, aggressive smoothing). This will allow users to select presets based on their needs.

## Context

- Part of the FilterCore implementation (P1)
- Required for P1.4 (Slider → params mapping)
- Presets should be perceptually distinct and cover a range of use cases
- Must integrate with the One Euro filter implementation (P1.2)

## Task Breakdown

### 1. Define Preset Parameters
- Research and define parameters for 3-5 presets (e.g., "Fine Control", "General Use", "Aggressive Smoothing")
- Each preset should have distinct `minCutoff`, `beta`, and `derivativeCutoff` values
- Ensure presets are perceptually distinct and cover a range of tremor severities

### 2. Implement Preset Mapping
- Create a `Preset` enum or struct to represent each preset
- Implement a mapping function to convert preset names to filter parameters
- Ensure presets are easily accessible and configurable

### 3. Integration with One Euro Filter
- Modify the `OneEuroFilter` class to accept preset parameters
- Ensure presets can be changed dynamically without recreating the filter
- Validate that preset changes are smooth and don't cause jumps in output

### 4. Unit Testing
- Write unit tests for preset mapping
- Verify that each preset produces distinct filtering behavior
- Ensure presets are reproducible across runs

## Test Cases (from TestPlan.md)

### Unit Tests
- **Preset validation**
  - Each preset produces perceptually distinct smoothing
  - Presets are reproducible across runs
  - Parameter ranges valid (no negative frequencies, etc.)

### Integration Tests
- **Preset switching**
  - Switching between presets is smooth (no jumps in output)
  - Preset changes are applied immediately
  - Preset parameters are correctly mapped to filter parameters

## Acceptance Criteria

- ✓ Preset mapping implemented and integrated with One Euro filter
- ✓ 3-5 distinct presets defined and tested
- ✓ Presets are perceptually distinct and cover a range of use cases
- ✓ Preset switching is smooth and doesn't cause jumps in output
- ✓ All unit tests pass (100% coverage)

## Quality Checklist

- [ ] Preset parameters defined and documented
- [ ] Preset mapping implemented and tested
- [ ] Integration with One Euro filter validated
- [ ] Unit tests written and passing
- [ ] Code reviewed and approved

## Implementation Templates

### Preset Definition
```swift
enum Preset {
    case fineControl
    case generalUse
    case aggressiveSmoothing

    var parameters: (minCutoff: Double, beta: Double, derivativeCutoff: Double) {
        switch self {
        case .fineControl:
            return (minCutoff: 1.0, beta: 0.1, derivativeCutoff: 1.0)
        case .generalUse:
            return (minCutoff: 2.0, beta: 0.2, derivativeCutoff: 2.0)
        case .aggressiveSmoothing:
            return (minCutoff: 3.0, beta: 0.3, derivativeCutoff: 3.0)
        }
    }
}
```

### Integration with One Euro Filter
```swift
extension OneEuroFilter {
    func applyPreset(_ preset: Preset) {
        let (minCutoff, beta, derivativeCutoff) = preset.parameters
        // Update filter parameters
    }
}
```

## Next Steps

1. Define preset parameters and create `Preset` enum
2. Implement preset mapping and integration with One Euro filter
3. Write unit tests for preset validation and switching
4. Validate integration and performance
5. Commit changes and push for review
6. Proceed to EXECUTE phase

## References

- `SPECS/PRD/Workplan.md` — Master task list
- `SPECS/PRD/TestPlan.md` — QA testing strategy
- `SPECS/RULES/01_PRD_PROMPT.md` — PRD generation rules
```

Now I will commit the PRD file.